<html lang="en">
<head>
<meta charset="UTF-8">
<meta "">
<title> The Area of the Pythagoras Tree </title>
<style>
text{
  transform:scaleY(-1);
}
svg{
  stroke-width:.03;
  font-size:0.3;
}
path,line{
  stroke:black;
}
</style>
</head>
<body style="max-width:600px; padding-left:10px;" >
<script id=header>

function draw(svg){
  document.getElementById(document.currentScript.id+"svg").innerHTML=svg;
}
function download(svg){
  // https://stackoverflow.com/questions/13405129/create-and-save-a-file-with-javascript
  let a = document.createElement("a");
  a.href = URL.createObjectURL(new Blob([svg],{type:"text/svg"}));
  a.download = document.currentScript.id+".svg"
//  document.body.appendChild(a);
  a.click()
}

</script>
<h1>The Area of the Pythagoras Tree</h1>
To spoil the surprise, the area of the Pythagoras Tree is exactly
<table style="text-align:center;"><tbody>
<tr><td style="border-bottom:2px solid black;">12823413011547414368862997525616691741041579688920794331363953564934456759066858494476606822552437442098640979</td></tr>
<tr><td>877512406035620068631903180662851572553488753575243048137500508983979170248733422547196905684808937723408093</td></tr>
</tbody></table>
(no, they don't have any common factors)

<p>
The Pythagoras Tree is a fractal constructed by taking a unit square and then recursively constructing 2 copies of the Pythagoras tree each scaled by a factor of 1/√2 and rotated 45° so that the bases of the copies of the original square form a right-angled isosceles triangle with the top edge of the original square.
</p>
<svg id=somethingsvg viewBox="-3.4 -0.4 7.8 4.8" style="transform:scaleY(-1)">
</svg>
<script type="text/javascript" id="something">
function drawScaled(l,r){
  // Draw 2 things scaled and rotated according to the transformations needed by the Pythagoras Tree
  return `<g transform="translate(0 1) rotate(45) scale(0.7071)">`+l+"</g>"+
    `<g transform="translate(0.5 1.5) rotate(-45) scale(0.7071)">`+r+"</g>"
}
function drawMany(n,thing){
  // Draw something many times in the shape of the Pythagoras tree
  if (n>0){
    let sub = drawMany(n-1,thing)
    return thing+drawScaled(sub,sub)
  }
  return ""
}
function grid(){
  let res=""
  for(c=-10;c<10;c++){
    res+=`<line style="stroke:gray" x1=${c} y1=-10 x2=${c} y2=10 />`
    res+=`<line style="stroke:gray" y1=${c} x1=-10 y2=${c} x2=10 />`
  }
  return res
}
draw(grid()+ drawMany(10,`<rect style="opacity:0.5;fill:blue" x=0 y=0 width=1 height=1 />`))
</script>

<h2>Some definitions</h2>
<h3> The Pythagoras Tree</h3>
<p>
Let d<sub>0</sub> be the transformation which rotates 45 degrees anticlockwise and scales by 1/√2 centered on (-1,1)
and let d<sub>1</sub> be the transformation which rotates 45 degrees clockwise and scales by 1/√2 centered on (2,1).
</p>
<p>
We define the <b>depth 1 rendering</b> of the Pythagoras tree to consist of an open unit square with corners at (0,0) and (1,1), and the depth n+1 rendering to consist of 2 copies of the depth n rendering transformed by d<sub>0</sub> and d<sub>1</sub> together with the unit square of the depth 1 rendering. This gives the arrangement described in Sec. \ref{sec:intro}. The Pythagoras tree is the union of the set of finite depth renderings.
</p>

<p>
We set out to find the exact area of the Pythagoras tree, which we will denote A. A is the limit of the sequence of the areas of the finite depth renderings.
This sequence starts 1, 2, 3, 4, 5, 5 <sup>15</sup>/<sub>16</sub>, 6 <sup>53</sup>/<sub>64</sub>,... . The limit of this monotone sequence exists since it is bounded above by the area of a 7x4 rectangle which no part of the shape leaves.
</p>
<svg id=depthssvg viewBox="-3.4 0 7.8 4" style="transform:scaleY(-1)">
</svg>
<script type="text/javascript" id="depths">
function translate(dx,dy,thing){
  return `<g transform="translate(${dx} ${dy})">${thing}</g>`
}
pict = ""
for(let i=1;i<=3;i++){
  pict += translate(i*2.7-5.8,1,
  drawMany(i,`<rect style="opacity:0.5;fill:blue" x=0 y=0 width=1 height=1 />`)+
  `<text y=0.3 font-size=0.3>Depth ${i}</text>`)
}
draw(pict)
</script>
<h3>Automata</h3>
<svg id=trianglesvg viewBox="-.015 -.015 2.03 2.03" style="transform:scaleY(-1);width:100px;float:left;margin:5px">
<path d="M 0 0 L 2 0 L 0 2 Z" />
<line style="stroke:lightgray" x1=1 y1=-10 x2=1 y2=10 />
<line style="stroke:lightgray" y1=1 x1=-10 y2=1 x2=10 />
<line style="stroke:gray" x1=0 y1=-10 x2=0 y2=10 />
<line style="stroke:gray" y1=0 x1=-10 y2=0 x2=10 />
<line style="stroke:gray" x1=2 y1=-10 x2=2 y2=10 />
<line style="stroke:gray" y1=2 x1=-10 y2=2 x2=10 />
</svg>
<p> Certain subsets of a unit square can be represented by dividing the square into 4 corners and describing what each quarter looks like. For shapes in which parts are copies of the whole, this can be done using a finite state automaton with the alphabet consisting of 4 symbols: tl (top left), tr (top right), bl (bottom left) and br (bottom right). For example, the triangle shown to the left can be described by the automaton below. The top left and bottom right corners are smaller copies of the triangle, while the bottom left and top right corners are full and empty respectively. </p>
<svg id=triangleautomatonsvg viewBox="-2.1 -0.4 4.2 1.7" style="transform:scaleY(-1)">
</svg>
<script id=triangleautomaton>
nodes = {}
function node(name,x,y){
  nodes[name]=[x,y]
}
function edge(src,dst,lab){
  [x1,y1]=nodes[src];
  [x2,y2]=nodes[dst];
  mx=(x1+x2)/2
  my=(y1+y2)/2
  dx=x2-x1;
  dy=y2-y1;
  d=Math.sqrt(dx*dx+dy*dy)
  x2-=.3*dx/d
  y2-=.3*dy/d
  return `<line x1=${x1} y1=${y1} x2=${x2} y2=${y2} />` +
    `<path d="M ${x2} ${y2} l ${(dy-dx)/d/5} ${(-dy-dx)/d/5} " />` +
    `<path d="M ${x2} ${y2} l ${(-dy-dx)/d/5} ${(-dy+dx)/d/5} " />` +
    `<text x=${mx-0.1} y=${my-0.05} font-size=0.15>${lab}</text>`
}
function loop(node,labs){
  [x,y]=nodes[node];
  txt = ""
  for(i in labs){
  txt +=`<text x=${x-0.3} y=${y-.9-i*.2} font-size=0.15>${labs[i]}</text>`
  }
  return `<path d="M ${x} ${y} c -1 1 .5 1 0 .3 l .22 .1 l -.22 -.1 l -.04 .24" fill=none />` +txt
}
function drawNodes(){
  return Object.keys(nodes).map(k=>  (([x,y]=nodes[k]),`<circle cx=${x} cy=${y} r=0.3 fill=white stroke=black /> <text y=${0.1-y} x=${x-0.1}>${k}</text>`)).join("")
}

node("T",0,0)
node("E",-1.5,0)
node("F",1.5,0)
pth = edge("T","E","tr")
pth += edge("T","F","bl")
pth += loop("T",["tl,br"])
pth += loop("E",["bl,tl","tr,br"])
pth += loop("F",["bl,tl","tr,br"])
draw(pth + drawNodes())
</script>
<p> This representation lets us calculate the area of the triangle. Call the area of the triangle $A_T$. Since the area of the triangle is the sum of the areas of each of the 4 corners, we have that $A_T = A_F/4 + 2A_T/4 + A_E/4$ where $A_F$ is the area of a full square and $A_E$ is the area of an empty square. As $A_F=1$ and $A_E=0$, we the equation becomes $A_T = 1/4 + A_T/2$. This lets us conclude that $A_T = 1/2$ i.e. the area of the triangle is exactly half that of the unit square.</p>


<h3 id="fn:automata">Footnote: Automata</h3>
<p>Technically we're using $\omega$-automata, which accept or reject infinte strings (F is the only accepting state, and every path that reaches it stays there forever, so we don't need a very fancy acceptance condition).
	Some points have multiple representations as infinite strings, but almost all of them don't, so we don't need to worry about them when calculating the area - formally, we are describing the points of the shape such that neither the x nor the y coordinate can be expressed as a*2<sup>b</sup> where a and b are integers. The excluded subset has measure 0, so this does not affect calculation of the area.
	
	Every open subset of the unit square can be described in this manner, if infinitely many states are allowed.</p>


<h3 id="fn:closure">Footnote: Closure</h3>

<p>Whether the squares are open or closed has no effect on the area of a finite depth rendering, therefore has no effect on the limit of the sequence of areas. Even if closed squares were used rather than open ones, the Pythagoras tree would not be closed, since it approaches but nevver reaches the line x=4.</p>

<p>Whether the closure of the Pythagoras tree has a different area from the Pythagoras tree is a question that could be addressed directly, but the automaton we constructed also describes the closure of the Pythagoras tree (except for some lines of the form  x±y=a*2<sup>b</sup> , for integers a and b which also have measure zero), so the areas of pieces of the closure of the Pythagoras tree satisfy the same system of linear equations. Since there is only one solution to that system, the area of the Pythagoras tree is equal to the area of its closure.</p>


<p>It was tempting to say (for convenience when dealing with automata) that the axis-aligned squares (added at odd depths) are closed while the other squares are open, but that smells a bit.</p>


<script id=t1>
console.log("t1 orig:" + document.currentScript.id)
//t2.innerHTML = `console.log("t2 changed:" + document.currentScript.id)`
</script>
<script id=t2>
console.log("t2 orig:" + document.currentScript.id)
t1.innerHTML = `console.log("t1 changed:" + document.currentScript.id)`
</script>

<script id=footer>
function editScript(txt, otherbut, scrid){
  return function(e){
    let but=e.target
    otherbut.style.display=""
    but.style.width="50%"
    txt.style.display=""
    console.log(scrid)
    but.innerText="hide code ^"
    but.onclick=hideScript(txt,otherbut,scrid)
  }
}
function hideScript(txt,otherbut,scrid){
  return function(e){
    let but=e.target
    otherbut.style.display="none"
    txt.style.display="none"
    but.style.width="100%"
    but.innerText="edit script V"
    but.onclick=editScript(txt,otherbut,scrid)
  }
}

for (let scr of document.getElementsByTagName("script")){
  if (scr.id!="header" && scr.id!="footer"){
    let but = document.createElement("button")
    let but2 = document.createElement("button")
    let txt = document.createElement("textarea")
    but.innerText="edit script V"
    but.style="width:100%"
    but.onclick=editScript(txt,but2,scr.id)
    scr.parentElement.insertBefore(but,scr)
    but2.style="display:none;width:50%"
    but2.innerText="Run Code"
    let scrid = scr.id
    but2.onclick = function(){
      document.getElementById(scrid).remove()
      let newScr=document.createElement("script")
      newScr.id=scrid
      newScr.innerHTML=txt.value
      document.body.append(newScr)
    }

    scr.parentElement.insertBefore(but2,scr)
    console.log(scr)
    txt.value=scr.innerText.trim();
    // https://stackoverflow.com/questions/881085/count-the-number-of-occurrences-of-a-character-in-a-string-in-javascript
    txt.rows=(scr.innerText.match(/\n/g) || []).length + 3
    txt.style="display:none;width:100%"
    scr.parentElement.insertBefore(txt,scr)
  }
}
</script>

</body>
</html>
